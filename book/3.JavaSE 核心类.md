# JavaSE 核心类

## Object 类

### toString

`toString` 返回能够描述当前类实例的字符串。

* 返回的字符串的格式是固定的：类名 @hashcode

* 这个 hashcode 是一串数字。在 Java 中叫句柄，或叫地址。
  这个地址不是真实的物理地址，Java 虚拟机根据这个地址查找真实的物理地址，防止程序直接更改地址。

```java
public class Point {
    int x, y;

    public Point() {}

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    //自定义坐标点输出格式
    public String toString() {
        return "(" + x + "," + y +")";
    }
}
```

### equals

`equals` 比较对象与给定对象内容是否一致

```java
public boolean equals(Object obj){
	//若 obj 的地址和当前对象地址一致，那么他们是同一个对象，equals 肯定要返回 true！
	if(this == obj){
	    return true;
	}

	//NullPointerException【空指针异常】
    if(obj==null){
        return false;
    }

    //ClassCastException【类造型异常】
    if(!(obj instanceof Point)){
        return false;
    }
}
```

## String 类

java.lang.String  UTF-8  Unicode

Java 字符串在内存中采用 Unicode  编码方式，一个字符串为两个字节。

* 字符串对象是不可变的。对字符串的任意操作，都会重新创建对象，而不会影响以前的对象！

* java 虚拟机就对 String 做了优化，将字符串保存在虚拟机内部的字符串常量池中。一旦要创建字符串，虚拟机会行先去常量池中检查是否创建过这个字符串，若有则直接引用。

**常用方法：**

方法 | 说明
---- | ----
`boolean equals()` | "Hello!".equals(s1)
`boolean equalsIgnoreCase()` | "Hello!".equalsIgnoreCase(s1)
`String toLowerCasse()` | "Hello!".toLowerCasse()
`String toUpperCase()` | "Hello!".toUpperCase()
`String trim()` | "Hello! ".trim()
`boolean startsWith()` | "Hello!".startsWith("He")
`boolean endsWith()` | "Hello!".endsWith("!")
`int length()` | "Hello!".length()
`int indexOf()` | "Hello!".indexOf("H", 5)，从第5位开始找，不存在返回-1
`int lastIndexOf()` | "Hello!".lastIndexOf()
`char charAt()` | "Hello!".charAt(2)，返回指定位置的字符
`String subString(start, end)` | "Hello!".subString(2)，包前不包后
`byte[] getBytes()` | "Hello!".getBytes()
`String[] split()` | "1.jpg".split("\\\.")
`String replaceAll()` | "1.jpg".replaceAll("\\\.", "AA")

* `getBytes()` 将字符串数组转化为字节数组。以当前系统默认的字符串编码集转换为字节

    * 编码：将数据以特定格式转换为字节

    * 解码：将字节以特定格式转换为数据
```java
import java.io.UnsupportedEncodingException;
import java.util.Arrays;

public class Test {
    public static void main(String[] args) throws UnsupportedEncodingException {
        //编码：将数据以特定格式转换为字节
        byte[] b = "我爱java".getBytes("utf-8");

        //解码：将字节以特定格式转换为数据
        String str = new String(b, "utf-8");

        System.out.println(Arrays.toString(b));
        // => [-26, -120, -111, -25, -120, -79, 106, 97, 118, 97]

        System.out.println(str);
        // => 我爱java
    }
}
```

## 正则表达式

### 正则表达式1：[]()

正则表达式 | 说明
---- | ----
^ | 正则表达式头，开始
$ | 正则表达式尾，结束
(abc) | 将一组字符看为一个整体
[] | 描述一个字符
| | 描述或关系
&& | 描述且关系
[abc] | a、b、c中任何一个字符
[^abc] | 除了a、b、c的任意一个字符
[a-z] | a、b、c、…、z中的任意一个字符
[a-zA-Z0-9] | a-z、A-Z、0-9中任意一个字符
[a-z&&[^bc]] | a-z不包括b或c

### 正则表达式2：量词

正则表达式 | 说明
---- | ----
X? | 表示0或1个X
X* | 表示0或任意多个X
X+ | 表示大于等于个X
X[n] | 表示n个X
X[n,] | 表示大于等于n个X
X[n,m] | 表示n到m个X

### 正则表达式3：特殊字符

正则表达式 | 说明
---- | ----
. | 任意一个字符
\d | 任意一个数字[0-9]
\D | 任意一个非数字[^0-9]
\s | 空白字符[\t\n\f\r]
\S | 非空白字符
\w | 任意一个单词字符，[a-zA-Z0-9_]
\W | 任意一个非单词字符，[^\w]

### 正则表达式4：转义字符

原字符 | 正则表达式 |java字符串
---- | ---- | ----
. | \\. | \\\\.
\+ | \\+ | \\\\+
\* | \\* | \\\\*
? | \\? | \\\\?

**如何描述正则表达式的"."？**

起因：

在正则表达式中描述 `.` 时，由于 `.` 在正则表达式中有特殊的含义，它代表任意字符，所以在正则表达式中想描述 `.` ，的愿意就要写成 `\.` 。

但是在用 Java 的字符串描述正则表达式的时候，因为 `.` 在 Java 字符串中没有特殊的含义，所以 Java 认为 `String s = "\."` 有语法错误的，因为 `.` 不需要转义。这就产生了冲突。

解决：

我们实际目的很简单，就是要让 Java 的字符串描述 `\.` ，在 Java 中 "\" 是有特殊含义的，代表转义字符
我们只需要将 "\" 转义为单纯的斜杠即可描述 "\." ，所以我们用 Java 描述 "\" 的正确写法是 **`String s= "\\."`**







