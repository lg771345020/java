# java 类

## 构造方法 == 构造器

* 构造器语法：在类中定义，方法类名一样！包括大小写，不能定义返回值。

* 构造器的作用：用于创建对象，初始化对象属性

* 构造器的参数：一般是初始化对象的前提条件

**注意：**

* 类一定有构造器：

    * 如果类没有声明任何的构造器，Java 编译器会自动插入默认构造器！默认构造是无参数，方法体是空的构造器。

    * 如果类声明了构造器，Java 编译器将不再提供默认构造器。

    * 建议：所有类都写无参构造器

* 子类中每一个构造器都必须调用父类的构造器：

    * 子类中默认调用父类无参数构造器。

    * 如果父类中没有无参数构造器，必须用 `super()` 手动调用父类构造器，否则发生编译错误。


## 访问权限

封装，将数据封装到类的内部，将算法封装到方法中。封装结果：存在但是不可见

修饰符 | 本类 | 包类 | 子类 | 跨包
---- | ---- | ---- | ---- | ----
public | √ | √ | √ | √
protected |	√ | √ |	√ | ×
默认 | √ | √ | × | ×
private | √ | × | × | ×

## final

* `final` 修饰的变量: 只能初始化(赋值)一次，不能再修改

* `final` 修饰的类: 不能再继承

* `final` 修饰的方法: 不能再重写

* `final` 修辞的方法参数：方法中不能再修改

**注意：** 企业编程规范：不允许使用final的方法和类！

```java
final String s = "ABC";
//s = "S";//编译错误

final String[] arr = {"A", "B"};
arr[0] = "AA";
System.out.println(Arrays.toString(arr));
// => [AA, B]

final Foo f = new Foo();
//f.a = 5;//编译错误
f.b = 6;//可以修改

class Foo {
    final int a =  5;
    int b =  5;
}
```

## static

* 静态方法使用类名调用，是属于类的方法

* 静态方法中没有隐含参数this！在静态方法没有this，在静态方法中不能访问this的属性和方法！

* 一般用于与当前对象无关的工具方法

**静态修饰的成员：**

属于类级别的成员，是全体类实例共享的资源

* 静态属性：只有一份，全体实例共享，类似于全局变量

* 静态方法：属于类的方法，使用类名直接调用，不需要创建对象。而且静态方法中没有隐含参数this，不能访问当前对象资源

* 静态代码块：在类加载间执行，只执行一次，可以用于加载。少用。代码块，在创建对象时候执行！类似于构造器的作用。几乎不用

静态代码块实例：

```java
//静态代码块
class Hello {
    //代码块，在创建对象时候执行！类似于构造器的作用。几乎不用
    {
        System.out.println("我是代码块");
    }

    //静态代码块：在类加载间执行，只执行一次，可以用于加载。少用
    static {
        System.out.println("我是静态代码块");
    }
}
```

运行以下代码：
```java
public class TestDs {
    public static void main(String[] args) {

        Hello h1 = new Hello();
        Hello h2 = new Hello();
        Hello h3 = new Hello();
        Hello h4 = new Hello();
    }
}
```

输出结果:
```java
我是静态代码块
我是代码块
我是代码块
我是代码块
我是代码块
```

## final 和 static 区别：

* final：实例变量，每个对象一份，不能再次修改

* static：静态，只有一份，可以被修改

* static final：共同修饰的叫常量

    * 常量：常量：PI 是直接数的代名词，是名字

    * 字面量(直接量)：直接写出数值 3.1415926535897

    * 宏观上：常量和字面量都是常量

## 关键字

* true、false、null 是字面量，不是关键字

* if else int ... 是关键字

